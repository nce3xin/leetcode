## 题意
实现归并排序。
## 思路
先将一个序列分成很多个不能再分割的子序列，将各个子序列分别排序后再将子序列合并。这里给出原位归并排序实现。

merge过程按如下方式进行：
* 回到我们玩扑克的例子，假设桌上有两堆牌面朝上的牌，每堆都已排序，最小的牌在顶上。我们希望把这两堆牌合并成单一的排好序的输出堆，牌面朝下地放在桌上。
* 我们的基本步骤包括在牌面朝上的两堆牌的顶上两张牌中选取较小的一张，将该牌从其堆中移开（该堆的顶上将显露一张新牌）并牌面朝下地将该牌放置到输出堆。
* 重复这个步骤，直到一个输入堆为空，这时，我们只是拿起剩余的输入堆并牌面朝下地将该堆放置到输出堆。
* 因为我们只是比较顶上的两张牌，所以计算上每个基本步骤需要常量时间。因为我们最多执行n个基本步骤，所以合并需要线性时间复杂度。
## 注意
* merge()函数里int k = left; 而不是int k=0。因为这里有递归的问题，不能直接写等于0，否则结果错误。
* merge过程中要首先创建2个辅助数组L和R，分别存放桌上的两堆牌。因此空间复杂度是O(n)。